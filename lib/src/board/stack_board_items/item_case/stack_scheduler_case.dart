import 'dart:async';
import 'package:flutter/material.dart';
import 'dart:convert';
import 'package:flutter_bloc/flutter_bloc.dart';
import '/src/di/service_locator.dart';
import '/src/repo/home_repo.dart';
import 'package:table_calendar/table_calendar.dart';
import '/src/board/flutter_stack_board.dart';
import '/src/repo/app_streams.dart';
import '/src/board/stack_board_items/items/stack_scheduler_item.dart';
import '/src/theme/theme_scheduler.dart';
import '/src/board/stack_board_items/item_case/common/api_utils.dart'
    as CommonApiUtils;

class StackSchedulerCase extends StatefulWidget {
  const StackSchedulerCase({
    super.key,
    required this.item,
    this.onScheduleTap,
    this.onScheduleAdd,
    this.onScheduleEdit,
    this.onScheduleDelete,
    this.onDateSelected,
    this.onViewChanged,
  });
  final StackSchedulerItem item;
  final Function(ScheduleData)? onScheduleTap;
  final Function(DateTime)? onScheduleAdd;
  final Function(ScheduleData)? onScheduleEdit;
  final Function(ScheduleData)? onScheduleDelete;
  final Function(DateTime)? onDateSelected;
  final Function(String)? onViewChanged;

  @override
  State<StackSchedulerCase> createState() => _StackSchedulerCaseState();
}

class _StackSchedulerCaseState extends State<StackSchedulerCase> {
  late StackSchedulerItem currentItem;
  late HomeRepo homeRepo;
  late AppStreams appStreams;
  late StreamSubscription _updateStackItemSub;
  late StreamSubscription _apiIdResponseSub;
  late StreamSubscription _rowResponseSub;

  late DateTime _focusedDay;
  late DateTime _selectedDay;
  late CalendarFormat _calendarFormat;
  late List<ScheduleData> _selectedEvents;
  late bool _isLoadingEvents;
  late bool isAllEvents;
  late Map<String, dynamic> initialValue, previousValue;
  late String theme;
  StackBoardController _controller(BuildContext context) =>
      StackBoardConfig.of(context).controller;

  @override
  void initState() {
    super.initState();
    currentItem = widget.item;
    theme = currentItem.theme;
    homeRepo = context.read<HomeRepo>();
    appStreams = sl<AppStreams>();
    _focusedDay = DateTime.now();
    _selectedDay = DateTime.now();
    _calendarFormat =
        _getCalendarFormat(currentItem.content?.viewType ?? 'month');
    _selectedEvents = [];
    _isLoadingEvents = false;
    isAllEvents = true;
    initialValue = {};
    previousValue = {};

    _subscribeUpdateStackItem();
    _subscribeApiIdResponse();
    _subscribeRowResponse();

    // apiIdÍ∞Ä ÏûàÏúºÎ©¥ Ï¥àÍ∏∞Ìôî Ïãú ÏûêÎèô API ÏöîÏ≤≠
    final apiId = currentItem.content?.apiId;
    if (apiId != null && apiId.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _loadEventsForDay(_selectedDay);
      });
    }
  }

  @override
  void didUpdateWidget(StackSchedulerCase oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.item != widget.item) {
      currentItem = widget.item;
      theme = currentItem.theme;
    }
  }

  CalendarFormat _getCalendarFormat(String viewType) {
    switch (viewType) {
      case 'month':
        return CalendarFormat.month;
      case '2weeks':
        return CalendarFormat.twoWeeks;
      case 'week':
        return CalendarFormat.week;
      default:
        return CalendarFormat.month;
    }
  }

  String _getViewTypeFromFormat(CalendarFormat format) {
    switch (format) {
      case CalendarFormat.month:
        return 'month';
      case CalendarFormat.twoWeeks:
        return '2weeks';
      case CalendarFormat.week:
        return 'week';
    }
  }

  void _subscribeUpdateStackItem() {
    _updateStackItemSub = appStreams.updateStackItemStream.listen((v) {
      if (v?.id == widget.item.id &&
          v is StackSchedulerItem &&
          v.boardId == widget.item.boardId) {
        final StackSchedulerItem item = v;
        setState(() {
          theme = item.theme;
          currentItem = item.copyWith(
              content: item.content?.copyWith(title: item.content?.title));
          _calendarFormat =
              _getCalendarFormat(currentItem.content?.viewType ?? 'month');
          _selectedEvents = [];

          // ÏúÑÏ†Ø ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏóêÎäî ÏûêÎèô Î°úÎìúÌïòÏßÄ ÏïäÏùå
        });

        homeRepo.hierarchicalControllers[widget.item.boardId]
            ?.updateItem(currentItem);
        debugPrint(
            'üìù _subscribeUpdateStackItem currentItem --> ${currentItem.toJson()}');
      }
    });
  }

  // row.json ÏàòÏã† Ïãú Ìò∏Ï∂ú
  void _subscribeRowResponse() {
    _rowResponseSub = homeRepo.rowResponseStream.listen((v) {
      if (v != null) {
        debugPrint('StackSchedulerCase: _subscribeRowResponse v = $v');
        setState(() {
          initialValue = {...initialValue, ...v};
          previousValue = initialValue;
          isAllEvents = false;
          _onDaySelected(_selectedDay, _focusedDay);
        });
      }
    });
  }

  void _subscribeApiIdResponse() {
    _apiIdResponseSub =
        CommonApiUtils.ApiUtils.subscribeApiIdResponse<StackSchedulerItem>(
      widget.item.boardId,
      widget.item.id,
      homeRepo,
      (item, receivedApiId, targetWidgetIds) =>
          _fetchResponseData(item, receivedApiId, targetWidgetIds),
    );
  }

  void _fetchResponseData(StackSchedulerItem item, String receivedApiId,
      List<String> targetWidgetIds) {
    // Í∏∞ÏÑ§Ï†ïÎêú API IDÏù¥Í±∞ÎÇò Í∞ïÏ†ú Ï£ºÏûÖ ÏöîÏ≤≠Ïù∏ÏßÄ Í≤ÄÏÇ¨
    if (!targetWidgetIds.contains(item.id)) {
      final response = homeRepo.onApiResponse[receivedApiId];
      if (response != null) {
        debugPrint('üìù _fetchResponseData response = $response');
      } else {
        debugPrint('üìù _fetchResponseData response = null');
      }
      return;
    }

    CommonApiUtils.ApiUtils.fetchResponseData<StackSchedulerItem>(
      item,
      receivedApiId,
      homeRepo,
      widget.item.boardId,
      widget.item.id,
      (currentContent) => widget.item.copyWith(
        content: widget.item.content!.copyWith(
          apiId: receivedApiId,
          apiParameters: CommonApiUtils.ApiUtils.extractParamKeysByApiId(
              homeRepo, receivedApiId),
        ),
      ),
      (updatedItem) => homeRepo.hierarchicalControllers[widget.item.boardId]
          ?.updateItem(updatedItem),
      (updatedItem) => homeRepo.addOnTapState(updatedItem),
      (updatedItem, apiParameters) => CommonApiUtils.ApiUtils
          .updateScriptFromApiParameters<StackSchedulerItem>(
        updatedItem,
        apiParameters,
        homeRepo,
        appStreams,
        (item) => item.copyWith(
            content: item.content?.copyWith(
                script: CommonApiUtils.ApiUtils.generateScript(apiParameters))),
        (updated) => homeRepo.updateStackItemState(updated),
        (updated) => appStreams.addOnTapState(updated),
      ),
    );
  }

  @override
  void dispose() {
    _updateStackItemSub.cancel();
    _apiIdResponseSub.cancel();
    _rowResponseSub.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final schedulerConfig = schedulerStyle(theme);
    return Column(
      children: [
        if (currentItem.content?.title?.isNotEmpty ?? false)
          _buildTitleHeader(schedulerConfig),
        _buildCalendar(schedulerConfig),
        Expanded(
          child: SingleChildScrollView(child: _buildEventList(schedulerConfig)),
        ),
      ],
    );
  }

  Widget _buildTitleHeader(SchedulerThemeConfig schedulerConfig) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: schedulerConfig.calendarBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(8.0),
          topRight: Radius.circular(8.0),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withValues(alpha: 0.2),
            spreadRadius: 1,
            blurRadius: 5,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Text(
        currentItem.content?.title ?? '',
        style: schedulerConfig.headerTextStyle,
        textAlign: TextAlign.center,
      ),
    );
  }

  Widget _buildCalendar(SchedulerThemeConfig schedulerConfig) {
    return Container(
      decoration: BoxDecoration(
        color: schedulerConfig.calendarBackgroundColor,
        borderRadius: const BorderRadius.only(
          topLeft: Radius.circular(8.0),
          topRight: Radius.circular(8.0),
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withValues(alpha: 0.2),
            spreadRadius: 1,
            blurRadius: 5,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: TableCalendar<ScheduleData>(
        firstDay: DateTime.utc(2020, 1, 1),
        lastDay: DateTime.utc(2030, 12, 31),
        focusedDay: _focusedDay,
        calendarFormat: _calendarFormat,
        availableCalendarFormats: const {
          CalendarFormat.month: 'ÏõîÎ≥Ñ',
          CalendarFormat.twoWeeks: '2Ï£º',
          CalendarFormat.week: 'Ï£ºÎ≥Ñ',
        },
        eventLoader: (day) {
          // Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞Î•º ÌëúÏãúÌïòÏßÄ ÏïäÏùå (Î¨¥Ï°∞Í±¥ API ÏöîÏ≤≠ÏúºÎ°ú ÏµúÏã† Îç∞Ïù¥ÌÑ∞ Î°úÎìú)
          return [];
        },
        startingDayOfWeek: StartingDayOfWeek.monday,
        rowHeight: 40,
        calendarStyle: CalendarStyle(
          outsideDaysVisible: false,
          weekendTextStyle: schedulerConfig.weekendTextStyle,
          holidayTextStyle: schedulerConfig.weekendTextStyle,
          defaultTextStyle: schedulerConfig.dateTextStyle,
          selectedTextStyle: const TextStyle(
            color: Colors.white,
          ),
          todayTextStyle: const TextStyle(
            color: Colors.white,
          ),
          selectedDecoration: BoxDecoration(
            color: schedulerConfig.selectedDateColor,
            shape: BoxShape.circle,
          ),
          todayDecoration: BoxDecoration(
            color: schedulerConfig.todayColor,
            shape: BoxShape.circle,
          ),
          markerDecoration: const BoxDecoration(
            color: Colors.red,
            shape: BoxShape.circle,
          ),
          markersMaxCount: 3,
          cellMargin: const EdgeInsets.all(2.0),
        ),
        headerStyle: HeaderStyle(
          formatButtonVisible: true,
          titleCentered: true,
          formatButtonShowsNext: false,
          formatButtonDecoration: BoxDecoration(
            color: schedulerConfig.selectedDateColor,
            borderRadius: BorderRadius.circular(12.0),
          ),
          formatButtonTextStyle: const TextStyle(
            color: Colors.white,
          ),
          titleTextStyle: schedulerConfig.headerTextStyle,
          leftChevronIcon: Icon(
            Icons.chevron_left,
            color: schedulerConfig.dateTextStyle.color,
          ),
          rightChevronIcon: Icon(
            Icons.chevron_right,
            color: schedulerConfig.dateTextStyle.color,
          ),
          rightChevronVisible: true,
          leftChevronVisible: true,
        ),
        calendarBuilders: CalendarBuilders(
          headerTitleBuilder: (context, day) {
            return Text(
              '${day.year}ÎÖÑ ${day.month}Ïõî',
              style: schedulerConfig.headerTextStyle,
            );
          },
        ),
        daysOfWeekStyle: DaysOfWeekStyle(
          weekdayStyle: schedulerConfig.weekdayTextStyle,
          weekendStyle: schedulerConfig.weekendTextStyle,
        ),
        onDaySelected: _onDaySelected,
        onFormatChanged: _onFormatChanged,
        onPageChanged: _onPageChanged,
        selectedDayPredicate: (day) {
          return isSameDay(_selectedDay, day);
        },
      ),
    );
  }

  /// ÎπÑÎèôÍ∏∞ Ïù¥Î≤§Ìä∏ Î°úÎìú (apiIdÍ∞Ä ÏûàÏùÑ ÎïåÎßå API ÏöîÏ≤≠)
  Future<List<ScheduleData>> _loadEventsForDayAsync(DateTime day) async {
    final apiId = currentItem.content?.apiId;
    if (apiId == null || apiId.isEmpty) {
      return []; // apiIdÍ∞Ä ÏóÜÏúºÎ©¥ Îπà Î™©Î°ù Î∞òÌôò
    }
    // apiIdÍ∞Ä ÏûàÏùÑ ÎïåÎßå API ÏöîÏ≤≠ Ïã§ÌñâÌïòÍ≥† Ìï¥Îãπ ÎÇ†Ïßú Ïù¥Î≤§Ìä∏ Î∞òÌôò
    return await _apiRequestForDay(day);
  }

  /// ÌäπÏ†ï ÎÇ†ÏßúÏóê ÎåÄÌïú API ÏöîÏ≤≠ Î∞è Ïù¥Î≤§Ìä∏ Î∞òÌôò
  Future<List<ScheduleData>> _apiRequestForDay(DateTime day) async {
    final apiId = currentItem.content?.apiId;
    if (apiId == null) return [];

    try {
      // 1. ÌååÎùºÎØ∏ÌÑ∞ Ï§ÄÎπÑ
      final allParams = {..._prepareApiParameters(), ...initialValue};

      // 2. API ÏöîÏ≤≠ Ïã§Ìñâ
      homeRepo.addApiRequest(apiId, allParams);

      // 3. ÏùëÎãµ ÎåÄÍ∏∞ (5Ï¥à ÌÉÄÏûÑÏïÑÏõÉ) - Î∞©Í∏à ÏöîÏ≤≠Ìïú ÌååÎùºÎØ∏ÌÑ∞ÏôÄ ÏùºÏπòÌïòÎäî ÏùëÎãµÎßå ÏÇ¨Ïö©
      final apiResponse = await _waitForApiResponse(apiId, allParams);
      if (apiResponse == null) {
        _showErrorSnackBar('API ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à)');
        return [];
      }

      // 4. Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î∞è Ìï¥Îãπ ÎÇ†Ïßú Ïù¥Î≤§Ìä∏ Î∞òÌôò
      return await _processScheduleDataForDay(apiResponse, day);
    } catch (e) {
      _showErrorSnackBar('API ÏöîÏ≤≠ Ïã§Ìå®: ${e.toString()}');
      return [];
    }
  }

  void _onDaySelected(DateTime selectedDay, DateTime focusedDay) {
    //if (!isSameDay(_selectedDay, selectedDay)) {
    setState(() {
      _selectedDay = selectedDay;
      _focusedDay = focusedDay;
    });

    // ÎπÑÎèôÍ∏∞Î°ú Ïù¥Î≤§Ìä∏ Î°úÎìú
    _loadEventsForDay(selectedDay);

    // ÎÇ†Ïßú ÏÑ†ÌÉù Ïãú ÏΩúÎ∞± Ìò∏Ï∂ú
    widget.onDateSelected?.call(selectedDay);
    //}
  }

  /// ÌäπÏ†ï ÎÇ†ÏßúÏùò Ïù¥Î≤§Ìä∏Î•º ÎπÑÎèôÍ∏∞Î°ú Î°úÎìú (Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ)
  Future<void> _loadEventsForDay(DateTime day) async {
    // Ïù¥ÎØ∏ Î°úÎî© Ï§ëÏù¥Î©¥ Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ
    if (_isLoadingEvents) {
      return;
    }

    try {
      _isLoadingEvents = true;
      final events = await _loadEventsForDayAsync(day);
      if (mounted) {
        setState(() {
          _selectedEvents = events;
        });
      }
    } catch (e) {
      // ÏóêÎü¨ Ï≤òÎ¶¨
    } finally {
      _isLoadingEvents = false;
    }
  }

  /// API ÌååÎùºÎØ∏ÌÑ∞ Ï§ÄÎπÑ
  Map<String, dynamic> _prepareApiParameters() {
    final parameters = CommonApiUtils.ApiUtils.parseApiParameters(
        currentItem.content?.apiParameters);
    final scriptConfig =
        CommonApiUtils.ApiUtils.parseScriptConfig(currentItem.content?.script);

    Map<String, dynamic> allParams = {};
    for (final param in parameters) {
      String key = param['paramKey'];
      String initValue = '';

      // Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÑ§Ï†ïÏóê Îî∞Î•∏ Í∞í Ìï†Îãπ
      if (scriptConfig.containsKey(key)) {
        final config = scriptConfig[key];
        initValue =
            CommonApiUtils.ApiUtils.getValueByScript(key, config!, null);
      } else {
        initValue = CommonApiUtils.ApiUtils.getDefaultValue(key, null);
      }

      // ÎÇ†Ïßú ÌååÎùºÎØ∏ÌÑ∞Ïóê Ïã§Ï†ú ÏÑ†ÌÉùÎêú ÎÇ†Ïßú ÏÑ§Ï†ï
      if (key == 'start_date' || key == 'end_date') {
        initValue = _selectedDay.toIso8601String().split('T')[0];
      }

      allParams[key] = initValue;
    }
    return allParams;
  }

  /// API ÏùëÎãµ ÎåÄÍ∏∞ (5Ï¥à ÌÉÄÏûÑÏïÑÏõÉ)
  /// ÎèôÏùº apiId ÏùëÎãµ Ï§ëÏóêÏÑúÎèÑ Î∞©Í∏à ÏöîÏ≤≠Ìïú ÌååÎùºÎØ∏ÌÑ∞ÏôÄ ÏùºÏπòÌïòÎäî ÏùëÎãµÎßå Î∞òÌôò
  Future<Map<String, dynamic>?> _waitForApiResponse(
      String apiId, Map<String, dynamic> expectedParams) async {
    int attempts = 0;
    const maxAttempts = 50; // 5Ï¥à ÎèôÏïà 100msÎßàÎã§ ÌôïÏù∏

    while (attempts < maxAttempts) {
      await Future.delayed(const Duration(milliseconds: 100));
      attempts++;

      final apiResponse = homeRepo.onApiResponse[apiId];
      if (apiResponse != null && apiResponse['data'] != null) {
        // ÏöîÏ≤≠ ÌååÎùºÎØ∏ÌÑ∞ ÏùºÏπò Ïó¨Î∂Ä ÌôïÏù∏
        final reqParams = apiResponse['reqParams'];
        if (reqParams is Map<String, dynamic>) {
          // ÌïµÏã¨ ÌååÎùºÎØ∏ÌÑ∞Îßå ÎπÑÍµê (start_date, end_date, id)
          final expStart = expectedParams['start_date']?.toString();
          final expEnd = expectedParams['end_date']?.toString();
          final expId = expectedParams['id']?.toString() ?? '';

          final gotStart = reqParams['start_date']?.toString();
          final gotEnd = reqParams['end_date']?.toString();
          final gotId = reqParams['id']?.toString() ?? '';

          // ÎÇ†ÏßúÏôÄ IDÍ∞Ä ÏùºÏπòÌïòÎ©¥ ÏÑ±Í≥µÏúºÎ°ú Í∞ÑÏ£º (Îπà Î¨∏ÏûêÏó¥Í≥º nullÏùÑ ÎèôÏùºÌïòÍ≤å Ï≤òÎ¶¨)
          final isMatch =
              expStart == gotStart && expEnd == gotEnd && expId == gotId;

          if (isMatch) {
            debugPrint('üìù _waitForApiResponse Îß§Ïπ≠ ÏÑ±Í≥µ: $apiResponse');
            return apiResponse;
          } else {
            debugPrint('üìù _waitForApiResponse Îß§Ïπ≠ Ïã§Ìå®:');
            debugPrint(
                '  expected: start_date=$expStart, end_date=$expEnd, id=$expId');
            debugPrint(
                '  received: start_date=$gotStart, end_date=$gotEnd, id=$gotId');
          }
        }
      }
    }
    debugPrint('üìù _waitForApiResponse ÌÉÄÏûÑÏïÑÏõÉ: 5Ï¥à ÌõÑ ÏùëÎãµ ÏóÜÏùå');
    return null;
  }

  /// Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Î∞è ÌäπÏ†ï ÎÇ†Ïßú Ïù¥Î≤§Ìä∏ Î∞òÌôò
  Future<List<ScheduleData>> _processScheduleDataForDay(
      Map<String, dynamic> apiResponse, DateTime day) async {
    final result = apiResponse['data']['result'];
    if (result is! List) {
      // API ÏùëÎãµÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÑ Îïå Í∏∞Ï°¥ Ï∫êÏã±Îêú Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
      if (mounted) {
        setState(() {
          _selectedEvents = [];
        });
      }
      return [];
    }

    // Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò
    final List<ScheduleData> newSchedules = result.map((scheduleJson) {
      return ScheduleData(
        id: scheduleJson['id']?.toString() ?? '',
        title: scheduleJson['title']?.toString() ?? '',
        date: DateTime.parse(scheduleJson['date']?.toString() ??
            DateTime.now().toIso8601String()),
        startTime: scheduleJson['start_time']?.toString() ?? '',
        endTime: scheduleJson['end_time']?.toString() ?? '',
        description: scheduleJson['description']?.toString() ?? '',
        status: scheduleJson['status']?.toString() ?? '',
      );
    }).toList();

    // Ìï¥Îãπ ÎÇ†ÏßúÏùò Ïù¥Î≤§Ìä∏Îßå Î®ºÏ†Ä ÌïÑÌÑ∞ÎßÅ (ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©)
    final dayEvents = newSchedules.where((schedule) {
      // UTC ÏãúÍ∞ÑÏùÑ Î°úÏª¨ ÏãúÍ∞ÑÏúºÎ°ú Î≥ÄÌôòÌïòÏó¨ ÎπÑÍµê
      final scheduleDate = schedule.date.toLocal();
      final targetDate = day;

      // ÎÖÑ, Ïõî, ÏùºÎßå ÎπÑÍµê (ÏãúÍ∞Ñ Î¨¥Ïãú)
      final scheduleYear = scheduleDate.year;
      final scheduleMonth = scheduleDate.month;
      final scheduleDay = scheduleDate.day;

      final targetYear = targetDate.year;
      final targetMonth = targetDate.month;
      final targetDay = targetDate.day;

      return scheduleYear == targetYear &&
          scheduleMonth == targetMonth &&
          scheduleDay == targetDay;
    }).toList();

    // ÏúÑÏ†Ø ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Î°ú ÏôÑÏ†Ñ ÍµêÏ≤¥)
    if (mounted) {
      setState(() {
        // Í∏∞Ï°¥ Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞Î•º ÏôÑÏ†ÑÌûà ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞Î°ú ÍµêÏ≤¥
        currentItem = currentItem.copyWith(
          content: currentItem.content?.copyWith(schedules: newSchedules),
        );
        // ÏÑ†ÌÉùÎêú Ïù¥Î≤§Ìä∏Îäî ÌïÑÌÑ∞ÎßÅÎêú Í≤∞Í≥ºÎ°ú ÏÑ§Ï†ï (Îπà Î∞∞Ïó¥Ïù¥Ïñ¥ÎèÑ Ï†ïÏÉÅ Ï≤òÎ¶¨)
        _selectedEvents = dayEvents;
      });

      // HomeRepoÏóê Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î∞òÏòÅ
      homeRepo.hierarchicalControllers[widget.item.boardId]
          ?.updateItem(currentItem);
      homeRepo.addOnTapState(currentItem);

      // Îπà Í≤∞Í≥ºÏùº ÎïåÎèÑ Ï†ÅÏ†àÌïú Î©îÏãúÏßÄ ÌëúÏãú
      if (dayEvents.isEmpty) {
        _showSuccessSnackBar('Ìï¥Îãπ ÎÇ†ÏßúÏóê Îì±Î°ùÎêú Ïä§ÏºÄÏ§ÑÏù¥ ÏóÜÏäµÎãàÎã§.');
      } else {
        _showSuccessSnackBar('Ïä§ÏºÄÏ§Ñ Îç∞Ïù¥ÌÑ∞ ${dayEvents.length}Í±¥ÏùÑ Î∂àÎü¨ÏôîÏäµÎãàÎã§.');
      }
    }

    return dayEvents;
  }

  /// ÏÑ±Í≥µ Î©îÏãúÏßÄ ÌëúÏãú
  void _showSuccessSnackBar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: Colors.green,
          duration: const Duration(seconds: 2),
        ),
      );
    }
  }

  /// ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú
  void _showErrorSnackBar(String message) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _onFormatChanged(CalendarFormat format) {
    setState(() {
      _calendarFormat = format;
      // Îã¨Î†• ÌòïÏãù Î≥ÄÍ≤Ω Ïãú ÏúÑÏ†Ø Îã§Ïãú Í∑∏Î¶¨Í∏∞
    });
    final viewType = _getViewTypeFromFormat(format);
    final item = widget.item.setViewType(viewType);
    _controller(context).updateItem(item);
    widget.onViewChanged?.call(viewType);
  }

  void _onPageChanged(DateTime focusedDay) {
    _focusedDay = focusedDay;

    // Îã¨Î†• ÌéòÏù¥ÏßÄ Î≥ÄÍ≤Ω ÏãúÏóêÎäî ÏûêÎèô Î°úÎìúÌïòÏßÄ ÏïäÏùå (ÏÇ¨Ïö©ÏûêÍ∞Ä ÏùºÏûêÎ•º ÏÑ†ÌÉùÌï† ÎïåÎßå Î°úÎìú)
  }

  Widget _buildEventList(SchedulerThemeConfig schedulerConfig) {
    return Column(
      children: [
        // Ìó§Îçî
        Container(
          decoration: BoxDecoration(
            color: schedulerConfig.eventListHeaderColor,
            borderRadius: const BorderRadius.only(
              bottomLeft: Radius.circular(8.0),
              bottomRight: Radius.circular(8.0),
            ),
          ),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '${_selectedDay.month}Ïõî ${_selectedDay.day}Ïùº ${isAllEvents ? 'Ï†ÑÏ≤¥' : ''} ÏùºÏ†ï',
                  style: schedulerConfig.headerTextStyle,
                ),
                Row(
                  children: [
                    Text(
                      '${_selectedEvents.length}Í∞ú',
                      style: TextStyle(
                        fontSize: 14,
                        color: schedulerConfig.dateTextStyle.color
                            ?.withValues(alpha: 0.6),
                      ),
                    ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.add),
                      onPressed: _onAddSchedule,
                      tooltip: 'ÏùºÏ†ï Ï∂îÍ∞Ä',
                    ),
                    if (initialValue != {} &&
                        previousValue != {} &&
                        !isAllEvents) ...[
                      const SizedBox(width: 8),
                      IconButton(
                        icon: isAllEvents
                            ? const Icon(Icons.person)
                            : const Icon(Icons.group),
                        onPressed: () {
                          setState(() {
                            isAllEvents = !isAllEvents;
                            initialValue = isAllEvents ? {} : previousValue;
                            _onDaySelected(_selectedDay, _focusedDay);
                          });
                        },
                        tooltip: 'Ï†ÑÏ≤¥ ÏùºÏ†ï Î≥¥Í∏∞',
                      ),
                    ]
                  ],
                ),
              ],
            ),
          ),
        ),
        // ÏùºÏ†ï Î™©Î°ù
        _isLoadingEvents
            ? const Padding(
                padding: EdgeInsets.all(16.0),
                child: Center(
                  child: CircularProgressIndicator(),
                ),
              )
            : _selectedEvents.isEmpty
                ? const Padding(
                    padding: EdgeInsets.all(16.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.start,
                      children: [
                        Icon(
                          Icons.event_note,
                          size: 48,
                          color: Colors.grey,
                        ),
                        SizedBox(height: 8),
                        Text(
                          'Îì±Î°ùÎêú ÏùºÏ†ïÏù¥ ÏóÜÏäµÎãàÎã§',
                          style: TextStyle(
                            fontSize: 14,
                            color: Colors.grey,
                          ),
                        ),
                      ],
                    ),
                  )
                : ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    padding: const EdgeInsets.all(8.0),
                    itemCount: _selectedEvents.length,
                    itemBuilder: (context, index) {
                      final event = _selectedEvents[index];
                      return _buildEventCard(event, schedulerConfig);
                    },
                  ),
      ],
    );
  }

  Widget _buildEventCard(
      ScheduleData event, SchedulerThemeConfig schedulerConfig) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4.0),
      color: schedulerConfig.eventCardBackgroundColor,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(8.0),
        side: BorderSide(color: schedulerConfig.eventCardBorderColor),
      ),
      child: ListTile(
        leading: Container(
          width: 4,
          height: 40,
          decoration: BoxDecoration(
            color: event.color ?? schedulerConfig.selectedDateColor,
            borderRadius: BorderRadius.circular(2),
          ),
        ),
        title: Text(
          event.title,
          style: schedulerConfig.headerTextStyle,
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (event.startTime != null && event.endTime != null)
              Text(
                '${event.startTime} - ${event.endTime}',
                style: schedulerConfig.dateTextStyle,
              ),
            if (event.description != null && event.description!.isNotEmpty)
              Text(
                event.description!,
                style: schedulerConfig.dateTextStyle,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
          ],
        ),
        trailing: PopupMenuButton<String>(
          onSelected: (value) => _handleScheduleAction(value, event),
          itemBuilder: (context) => [
            const PopupMenuItem(
              value: 'edit',
              child: Text('ÏàòÏ†ï'),
            ),
            const PopupMenuItem(
              value: 'delete',
              child: Text('ÏÇ≠Ï†ú'),
            ),
          ],
        ),
        onTap: () => _showEditScheduleDialog(event),
      ),
    );
  }

  void _onAddSchedule() {
    widget.onScheduleAdd?.call(_selectedDay);
    showDialog(
      context: context,
      builder: (context) => _ScheduleEditDialog(
        date: _selectedDay,
        onSave: (schedule) {
          _addSchedule(schedule);
        },
      ),
    );
  }

  void _showEditScheduleDialog(ScheduleData schedule) {
    showDialog(
      context: context,
      builder: (context) => _ScheduleEditDialog(
        date: _selectedDay,
        schedule: schedule,
        onSave: (updatedSchedule) {
          _updateSchedule(updatedSchedule);
        },
      ),
    );
  }

  void _handleScheduleAction(String action, ScheduleData schedule) {
    switch (action) {
      case 'edit':
        _showEditScheduleDialog(schedule);
        break;
      case 'delete':
        _showDeleteConfirmDialog(schedule);
        break;
    }
  }

  void _showDeleteConfirmDialog(ScheduleData schedule) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ÏùºÏ†ï ÏÇ≠Ï†ú'),
        content: Text('"${schedule.title}" ÏùºÏ†ïÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('Ï∑®ÏÜå'),
          ),
          TextButton(
            onPressed: () {
              _deleteSchedule(schedule.id);
              Navigator.of(context).pop();
            },
            child: const Text('ÏÇ≠Ï†ú'),
          ),
        ],
      ),
    );
  }

  Future<void> _addSchedule(ScheduleData event) async {
    final apiId = currentItem.content?.postApiId;
    if (apiId == null || apiId.isEmpty) {
      _showErrorSnackBar('ÏÉùÏÑ± APIÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      return;
    }

    final params = _buildCrudParams(apiId, schedule: event);
    // ÏöîÏ≤≠ Ïã§Ìñâ (_apiRequestForDayÏôÄ ÎèôÏùºÌïú Ìå®ÌÑ¥)
    homeRepo.addApiRequest(apiId, params);
    final resp = await _waitForApiResponse(apiId, params);
    if (resp == null) {
      _showErrorSnackBar('ÏùºÏ†ï Ï∂îÍ∞Ä ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à)');
      return;
    }
    _showSuccessSnackBar('ÏùºÏ†ïÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.');
    await _refreshCurrentDayWithRetry();
  }

  Future<void> _updateSchedule(ScheduleData event) async {
    final apiId = currentItem.content?.putApiId;
    if (apiId == null || apiId.isEmpty) {
      _showErrorSnackBar('ÏàòÏ†ï APIÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      return;
    }

    final params = _buildCrudParams(apiId, schedule: event);
    homeRepo.addApiRequest(apiId, params);
    final resp = await _waitForApiResponse(apiId, params);
    if (resp == null) {
      _showErrorSnackBar('ÏùºÏ†ï ÏàòÏ†ï ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à)');
      return;
    }
    _showSuccessSnackBar('ÏùºÏ†ïÏù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.');
    await _refreshCurrentDayWithRetry();
  }

  Future<void> _deleteSchedule(String eventId) async {
    final apiId = currentItem.content?.deleteApiId;
    if (apiId == null || apiId.isEmpty) {
      _showErrorSnackBar('ÏÇ≠Ï†ú APIÍ∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.');
      return;
    }

    // ÎåÄÏÉÅ ÏùºÏ†ï Ï°∞Ìöå(Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏïÑÎèÑ idÎßåÏúºÎ°ú ÏßÑÌñâ Í∞ÄÎä•)
    final schedule = currentItem.content?.schedules?.firstWhere(
      (s) => s.id == eventId,
      orElse: () => ScheduleData(id: eventId, title: '', date: DateTime.now()),
    );

    final params = _buildCrudParams(apiId, schedule: schedule);
    homeRepo.addApiRequest(apiId, params);
    final resp = await _waitForApiResponse(apiId, params);
    if (resp == null) {
      _showErrorSnackBar('ÏùºÏ†ï ÏÇ≠Ï†ú ÏùëÎãµ ÌÉÄÏûÑÏïÑÏõÉ (5Ï¥à)');
      return;
    }
    _showSuccessSnackBar('ÏùºÏ†ïÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');
    await _refreshCurrentDayWithRetry();
  }

  /// ÌòÑÏû¨ ÏÑ†ÌÉùÏùºÏûê Í∞ïÏ†ú Ïû¨Ï°∞Ìöå + ÏßßÏùÄ Ïû¨ÏãúÎèÑÎ°ú UI ÎèôÍ∏∞Ìôî Î≥¥Í∞ï
  Future<void> _refreshCurrentDayWithRetry() async {
    final previous = List<ScheduleData>.from(_selectedEvents);
    const int maxAttempts = 5;
    for (int i = 0; i < maxAttempts; i++) {
      final events = await _loadEventsForDayAsync(_selectedDay);
      if (mounted) {
        setState(() {
          _selectedEvents = events;
        });
      }
      if (_areSchedulesDifferent(previous, events)) break;
      await Future.delayed(const Duration(milliseconds: 200));
    }
  }

  bool _areSchedulesDifferent(List<ScheduleData> a, List<ScheduleData> b) {
    if (identical(a, b)) return false;
    if (a.length != b.length) return true;
    for (int i = 0; i < a.length; i++) {
      if (a[i].id != b[i].id ||
          a[i].title != b[i].title ||
          a[i].startTime != b[i].startTime ||
          a[i].endTime != b[i].endTime ||
          a[i].status != b[i].status ||
          a[i].description != b[i].description) {
        return true;
      }
    }
    return false;
  }

  /// CRUD API Î©îÌÉÄÏùò parametersÎ•º ÏùΩÏñ¥ Ïä§ÏºÄÏ§ÑÏóêÏÑú Í∞í Îß§Ìïë (Î≤îÏö©, ÌïòÎìúÏΩîÎî© ÏµúÏÜåÌôî)
  Map<String, dynamic> _buildCrudParams(String apiId,
      {ScheduleData? schedule}) {
    // initialValueÏóêÏÑú nullÏù¥ÎÇò Îπà Î¨∏ÏûêÏó¥Ïù¥ ÏïÑÎãå Í∞íÎßå ÏÇ¨Ïö©
    final params = <String, dynamic>{};
    initialValue.forEach((key, value) {
      if (value != null && (value is! String || value.isNotEmpty)) {
        params[key] = value;
      }
    });

    final api = homeRepo.apis[apiId];
    if (api == null) return params;

    List<dynamic> paramDefs = [];
    try {
      final raw = api['parameters'];
      if (raw != null && raw.toString().isNotEmpty) {
        paramDefs = raw is String ? jsonDecode(raw) : (raw as List<dynamic>);
      }
    } catch (_) {
      // ignore
    }

    String? toDateStr(DateTime? dt) =>
        dt?.toIso8601String().split('T').first; // YYYY-MM-DD

    String? toTimeStr(String? t) {
      if (t == null || t.isEmpty) return '00:00:00';
      final s = t.trim();
      // HH:mm -> HH:mm:00 Î≥¥Ï†ï
      final hhmm = RegExp(r'^\d{2}:\d{2}$');
      if (hhmm.hasMatch(s)) return '$s:00';
      // HHmm -> HH:mm:00 Î≥¥Ï†ï
      final hhmmComp = RegExp(r'^(\d{2})(\d{2})$');
      final m = hhmmComp.firstMatch(s);
      if (m != null) return '${m.group(1)}:${m.group(2)}:00';
      // Ïù¥ÎØ∏ HH:mm:ss ÎòêÎäî Í∏∞ÌÉÄ Ìè¨Îß∑ÏùÄ Í∑∏ÎåÄÎ°ú
      return s;
    }

    for (final def in paramDefs) {
      if (def is! Map) continue;
      final key = def['paramKey']?.toString();
      if (key == null || key.isEmpty) continue;

      dynamic value;
      // Ïä§ÏºÄÏ§Ñ ÌïÑÎìúÎ™ÖÍ≥º paramKeyÍ∞Ä ÎèôÏùº/Ïú†ÏÇ¨Ìï† Îïå ÏûêÎèô Îß§Ìïë
      switch (key) {
        case 'id':
          // ÏàòÏ†ï ÏãúÏóêÎäî scheduleÏùò idÎ•º, ÏÉùÏÑ± ÏãúÏóêÎäî initialValueÏùò idÎ•º ÏÇ¨Ïö©
          value = schedule?.id ?? initialValue['id'];
          break;
        case 'title':
          value = schedule?.title;
          break;
        case 'notes':
          // ÏÑúÎ≤ÑÍ∞Ä notesÏóêÏÑú title|description Î∂ÑÎ¶¨ÌïòÎäî Í≤ΩÏö∞ ÏßÄÏõê
          final title = schedule?.title ?? '';
          final desc = schedule?.description ?? '';
          value = '$title|$desc';
          break;
        case 'date':
          value = toDateStr(schedule?.date);
          break;
        case 'start_time':
          value = toTimeStr(schedule?.startTime);
          break;
        case 'end_time':
          value = toTimeStr(schedule?.endTime);
          break;
        case 'description':
          value = schedule?.description;
          break;
        case 'status':
          value = schedule?.status;
          break;
        case 'created_by':
        case 'user_id':
          // initialValueÏóêÏÑú user_idÎ•º Í∞ÄÏ†∏Ïò§Í±∞ÎÇò, ÏóÜÏúºÎ©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
          value = initialValue['user_id'] ?? initialValue['id'] ?? '1';
          break;
        default:
          // Í∏∞Î≥∏Í∞íÏùÄ Îπà Î¨∏ÏûêÏó¥Î°ú Ï±ÑÏõÄ (ÏÑúÎ≤ÑÏóêÏÑú ÏÑ†ÌÉùÏ†Å Ï≤òÎ¶¨)
          value = '';
      }

      value ??= '';
      params[key] = value;
    }

    return params;
  }
}

class _ScheduleEditDialog extends StatefulWidget {
  const _ScheduleEditDialog({
    required this.date,
    this.schedule,
    required this.onSave,
  });
  final DateTime date;
  final ScheduleData? schedule;
  final Function(ScheduleData) onSave;
  @override
  State<_ScheduleEditDialog> createState() => _ScheduleEditDialogState();
}

class _ScheduleEditDialogState extends State<_ScheduleEditDialog> {
  late TextEditingController _titleController;
  late TextEditingController _descriptionController;
  late TextEditingController _startTimeController;
  late TextEditingController _endTimeController;
  String _status = 'ÏòàÏ†ï';
  Color _color = Colors.blue;
  @override
  void initState() {
    super.initState();
    _titleController =
        TextEditingController(text: widget.schedule?.title ?? '');
    _descriptionController =
        TextEditingController(text: widget.schedule?.description ?? '');

    // ÏãúÍ∞Ñ Í∏∞Î≥∏Í∞í: ÏÉà ÏùºÏ†ï Ï∂îÍ∞Ä Ïãú ÌòÑÏû¨ÏãúÍ∞Ñ, ÌòÑÏû¨ÏãúÍ∞Ñ+1h
    String fmtTime(DateTime dt) {
      final hh = dt.hour.toString().padLeft(2, '0');
      final mm = dt.minute.toString().padLeft(2, '0');
      return '$hh:$mm';
    }

    final now = DateTime.now();
    final defStart = fmtTime(widget.schedule?.date ?? now);
    final defEnd =
        fmtTime((widget.schedule?.date ?? now).add(const Duration(hours: 1)));

    _startTimeController =
        TextEditingController(text: widget.schedule?.startTime ?? defStart);
    _endTimeController =
        TextEditingController(text: widget.schedule?.endTime ?? defEnd);
    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî: ÌóàÏö©Í∞í Ïù¥Ïô∏Î©¥ Í∏∞Î≥∏Í∞íÏúºÎ°ú Î≥¥Ï†ï
    const allowedStatuses = ['ÏòàÏ†ï', 'ÌôïÏ†ï', 'ÏôÑÎ£å', 'Ï∑®ÏÜå'];
    final initStatus = widget.schedule?.status?.trim();
    _status = (initStatus != null && allowedStatuses.contains(initStatus))
        ? initStatus
        : 'ÏòàÏ†ï';
    _color = widget.schedule?.color ?? Colors.blue;
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    _startTimeController.dispose();
    _endTimeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text(widget.schedule == null ? 'ÏùºÏ†ï Ï∂îÍ∞Ä' : 'ÏùºÏ†ï ÏàòÏ†ï'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: _titleController,
              decoration: const InputDecoration(
                labelText: 'Ï†úÎ™©',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _descriptionController,
              decoration: const InputDecoration(
                labelText: 'ÏÑ§Î™Ö',
                border: OutlineInputBorder(),
              ),
              maxLines: 3,
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                    child: _HourStepper(
                  label: 'ÏãúÏûë ÏãúÍ∞Ñ',
                  controller: _startTimeController,
                )),
                const SizedBox(width: 16),
                Expanded(
                    child: _HourStepper(
                  label: 'Ï¢ÖÎ£å ÏãúÍ∞Ñ',
                  controller: _endTimeController,
                )),
              ],
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: const ['ÏòàÏ†ï', 'ÌôïÏ†ï', 'ÏôÑÎ£å', 'Ï∑®ÏÜå'].contains(_status)
                  ? _status
                  : null,
              decoration: const InputDecoration(
                labelText: 'ÏÉÅÌÉú',
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(value: 'ÏòàÏ†ï', child: Text('ÏòàÏ†ï')),
                DropdownMenuItem(value: 'ÌôïÏ†ï', child: Text('ÌôïÏ†ï')),
                DropdownMenuItem(value: 'ÏôÑÎ£å', child: Text('ÏôÑÎ£å')),
                DropdownMenuItem(value: 'Ï∑®ÏÜå', child: Text('Ï∑®ÏÜå')),
              ],
              onChanged: (value) {
                setState(() {
                  _status = value ?? 'ÏòàÏ†ï';
                });
              },
              hint: const Text('ÏÉÅÌÉú ÏÑ†ÌÉù'),
            ),
            const SizedBox(height: 16),
            Text(
              'ÎÇ†Ïßú: ${widget.date.year}ÎÖÑ ${widget.date.month}Ïõî ${widget.date.day}Ïùº',
              style: const TextStyle(
                fontSize: 14,
                color: Colors.black54,
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('Ï∑®ÏÜå'),
        ),
        TextButton(
          onPressed: _saveSchedule,
          child: const Text('Ï†ÄÏû•'),
        ),
      ],
    );
  }

  void _saveSchedule() {
    if (_titleController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Ï†úÎ™©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî')),
      );
      return;
    }
    // ÏûÖÎ†•Í∞í Ï†ïÍ∑úÌôî (Îπà Í∞íÏù¥Î©¥ Í∏∞Î≥∏Í∞í Ï†ÅÏö©)
    String normalizeTime(String v) {
      final s = v.trim();
      if (s.isEmpty) return '00:00';
      return s;
    }

    final schedule = ScheduleData(
      id: widget.schedule?.id ??
          DateTime.now().millisecondsSinceEpoch.toString(),
      title: _titleController.text.trim(),
      date: widget.schedule?.date ?? widget.date,
      startTime: normalizeTime(_startTimeController.text),
      endTime: normalizeTime(_endTimeController.text),
      description: _descriptionController.text.trim().isEmpty
          ? null
          : _descriptionController.text.trim(),
      status: _status,
      color: _color,
      userId: widget.schedule?.userId ?? 'user1',
    );
    widget.onSave(schedule);
    Navigator.of(context).pop();
  }
}

class _HourStepper extends StatefulWidget {
  const _HourStepper({required this.label, required this.controller});
  final String label;
  final TextEditingController controller;
  @override
  State<_HourStepper> createState() => _HourStepperState();
}

class _HourStepperState extends State<_HourStepper> {
  late int hour;

  @override
  void initState() {
    super.initState();
    hour = int.tryParse(widget.controller.text.split(':').first) ?? 0;
    hour = hour.clamp(0, 23);
    _sync();
  }

  void _sync() {
    final hh = hour.toString().padLeft(2, '0');
    widget.controller.text = '$hh:00';
  }

  void _inc() {
    setState(() {
      hour = (hour + 1) % 24;
      _sync();
    });
  }

  void _dec() {
    setState(() {
      hour = (hour - 1) < 0 ? 23 : (hour - 1);
      _sync();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        IconButton(onPressed: _dec, icon: const Icon(Icons.remove)),
        Expanded(
          child: TextField(
            controller: widget.controller,
            readOnly: true,
            textAlign: TextAlign.center,
            decoration: InputDecoration(
              labelText: widget.label,
              border: const OutlineInputBorder(),
            ),
          ),
        ),
        IconButton(onPressed: _inc, icon: const Icon(Icons.add)),
      ],
    );
  }
}
